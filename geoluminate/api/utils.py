from logging import getLogger

from django.conf import settings
from django.template import TemplateDoesNotExist
from django.template.loader import render_to_string
from drf_spectacular.openapi import AutoSchema
from rest_framework_gis import filters
from rest_framework_nested.viewsets import NestedViewSetMixin

logger = getLogger(__name__)


class DistanceToPointOrderingFilter(filters.DistanceToPointOrderingFilter):
    def get_schema_operation_parameters(self, view):
        params = super().get_schema_operation_parameters(view)
        params.append(
            {
                "name": self.order_param,
                "required": False,
                "in": "query",
                "description": "",
                "schema": {
                    "type": "enum",
                    "items": {"type": "string", "enum": ["asc", "desc"]},
                    "example": "desc",
                },
                "style": "form",
                "explode": False,
            }
        )
        return params


def public_api(endpoints):
    """A filter function that will exclude urls generated by this package
    from being included in any API documentation generated using
    `drf-spectacular <https://github.com/tfranzel/drf-spectacular>`_.

    You can use this function by placing it in your `SPECTACULAR_SETTINGS`
    config dictionary under `PREPROCCESSING_HOOKS`. E.g.

    .. code:: python


    "PREPROCESSING_HOOKS": [
        "datatables.spectacular.preprocessing_filter_spec"
    ],


    """
    filtered = []
    for path, path_regex, method, callback in endpoints:
        # Remove all but DRF API endpoints
        if path.startswith("/api/"):
            filtered.append((path, path_regex, method, callback))
        # filtered.append((path, path_regex, method, callback))
    return filtered


def api_doc(model, path):
    try:
        template = f"api/docs/{model._meta.model_name.lower()}_{path}.md"
        return render_to_string(template, context={"model": model, "geoluminate": settings.GEOLUMINATE})
    except TemplateDoesNotExist:
        logger.warning(f"Template {template} does not exist.")
    return ""


# class CustomSchema(AutoSchema):
#     def get_operation(self, path, path_regex, path_prefix, method, registry):
#         operation = super().get_operation(path, path_regex, path_prefix, method, registry)
#         print(operation.__dict__)
#         qs = getattr(self.view, "queryset", None)
#         if qs is not None:
#             desc = api_doc(qs.model, method.lower())
#             # print(desc)
#             if desc:
#                 operation["description"] = desc
#         return operation

#     # def get_description(self):
#     #     if hasattr(self.view, "queryset") and (desc := api_doc(self.view.queryset.model, "list")):
#     #         return desc
#     #     return super().get_description()


class NestedViewset(NestedViewSetMixin):
    """Subclass the default NestedViewSetMixin to make prevent a key error when generatin the schema with DRF Spectacular."""

    def initialize_request(self, request, *args, **kwargs):
        if getattr(self, "swagger_fake_view", False):
            return request
        return super().initialize_request(request, *args, **kwargs)

    def get_serializer_class(self):
        if renderer := getattr(self.request, "accepted_renderer", None):
            if renderer.format == "geojson":
                return self.geojson_serializer
        return super().get_serializer_class()

    def paginate_queryset(self, queryset, view=None):
        if renderer := getattr(self.request, "accepted_renderer", None):
            if renderer.format == "geojson":
                return None
        return self.paginator.paginate_queryset(queryset, self.request, view=self)
